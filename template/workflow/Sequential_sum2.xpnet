
<defun name="template">
<!-- Struct definitions -->
    <struct name="Std_basis">
        <field name="InputGB" type="string"/>
        <field name="ngen" type="int"/>
    </struct>
      <struct name="lifting">
        <field name="lead_Syz" type="string"/>
        <field name="lift" type="string"/>
        <field name="leadsyz_count" type="int"/>
    </struct>

	<in name="base_filename" type="string" place="place_base_filename"/>
	<in name="library_name" type="string" place="place_library_name"/>
  <in name="input" type="string" place="place_initiate"/>
 <out name ="OUTPUT" type ="string" place ="place_Final_Syz"/>
  
	<net>
  <place name ="place_initiate" type ="string"/>
 
    <place name ="place_input_GB" type ="string"/>
		<place name="place_base_filename" type="string"/>
		<place name="place_library_name" type="string"/>
     <place name ="place_All_Lead" type ="string"/>
    
    <place name="place_lead" type="string"/>
    <place name="place_Tau" type="string"/>
    <place name ="place_SubLift" type ="string"/>
    <place name ="place_Syz" type ="string"/>

 
    <place name="place_counter" type="int"/>
 
 







  <!-- Transition: StartTime -->
    <transition name="StartTime">
      <defun>
       <out name ="c" type ="control"/>
      <in name="input" type="string"/>
        <out name="output" type="string"/>
      
        <module name="singular_template" function="StartTime(input,c,output)">
         <cinclude href="interface/template_interface.hpp" />
      <cinclude href="util-generic/dynamic_linking.hpp"/>
      <cinclude href="iostream"/>
      <cinclude href="chrono"/>
        <code><![CDATA[

     output=input;
    ]]></code>
     </module>
     
  
    
    
      </defun>
      <connect-in port="input" place="place_initiate"/>
     
       <connect-out port="output" place="place_input_GB"/>
        <connect-out port="c" place="place_control"/>
    </transition>
    
   

<place name="place_control_All_Lead" type="control">
  <token><value>[]</value></token>
</place>


 <place name="place_length_Res" type="int">
  
</place>

    <!-- transition_compute-->
  
     <transition name="All_Lead">
      <defun>
        <require key="worker" mandatory="true"/>
        		
        <in name="library_name" type="string"/>
        <in name="base_filename" type="string"/>
				   
        		<out name="OUTPUT" type="list"/>
           <in name ="C" type="control"/>
           <out name ="counter" type="int"/>
           <in name ="init" type ="string"/>
        		<module name="singular_template"
              		require_function_unloads_without_rest="false"
              		function="All_Lead(init, OUTPUT,C, counter,library_name, base_filename)">
          		<cinclude href="interface/template_interface.hpp" />
          		<cinclude href="util-generic/dynamic_linking.hpp"/>
        <cinclude href="vector"/>
        <cinclude href="iostream"/>
        <cinclude href ="string"/>
        <cinclude href="list"/>
        <cinclude href="numeric"/> 
         <cinclude href="chrono"/>
          			<code><![CDATA[
          //std::cout <<"All_LeadSyz_Input:"<<init<< std::endl;
           auto start_computation = std::chrono::high_resolution_clock::now();
				std::tuple<std::vector<std::string>, int, long> out = RESOLVE_INTERFACE_FUNCTION( singular_template_ALL_LEAD) (init,library_name, base_filename);
              

                std::vector<std::string> vec = std::get<0>(out);
                     counter = std::get<1>(out);
                    //  auto runtime = std::get<2>(out);
             
                    
                 for(int i (0); i<vec.size(); i++)
                                                                 {
                        // std::cout << "SchFrame_Success:"<<vec[i] << std::endl;
                       
                          OUTPUT.emplace_back(vec[i]);

                    }
            std::cout << "place_SchFrame_counter: " << counter << std::endl;
            // std::cout << "total_runtime_SchFrame = " << runtime << " nanoseconds" << std::endl;
          
            		]]></code>
        		</module>
      		</defun>
      	<connect-read port="library_name" place="place_library_name"/>
        <connect-read port="base_filename" place="place_base_filename"/>
			  <connect-read port="init" place="place_input_GB"/>
        <connect-in port="C" place="place_control_All_Lead"/>

       
       <connect-out port="counter" place="place_length_Res"/>
			  <connect-out-many port="OUTPUT" place="place_All_Lead"/>
      
        
  		  </transition>



<place name="place_control" type="control">

</place>


        <!-- Transition 1: lead -->
    <transition name="LEADSYZ">
     <defun>
        <require key="worker" mandatory="true"/>
        <in name="library_name" type="string"/>
        <in name="base_filename" type="string"/>
        <in name="input" type="string"/>
        <in name ="s" type ="control"/>
 
       <out name ="Sublift" type ="list"/>
        <out name="counter" type="int"/>
        <out name="OUT" type="list"/>
        <out name="syz_sum" type="list"/>
      <module name="singular_template"
                require_function_unloads_without_rest="false"
                function="leadsyz(input,s,counter,OUT,library_name,base_filename,Sublift,syz_sum)">
        <cinclude href="interface/template_interface.hpp" />
        <cinclude href="util-generic/dynamic_linking.hpp"/>
        <cinclude href="vector"/>
        <cinclude href="iostream"/>
        <cinclude href ="string"/>
        <cinclude href="list"/>
        <cinclude href="numeric"/> 
        <cinclude href="chrono"/>

            <code><![CDATA[
            
            
                  std::tuple<std::vector<std::string>, int, long> out = RESOLVE_INTERFACE_FUNCTION(singular_template_LEAD)
                        (input, library_name, base_filename);
                      std::vector<std::string> vec = std::get<0>(out);
                      int total_generator = std::get<1>(out);
                    
                    
                      counter=total_generator;
                        for(int i (0); i<total_generator; i++)
                                                                 {
                          //std::cout << "leadSyz_Success:"<<vec[i] << std::endl;
                          OUT.emplace_back(vec[i]);
                          
                         //std::cout << "leadSyz_Success:"<<vec[i] << std::endl;
                          //std::cout << "SubliftleadSyz_Success:"<<vec[i] << std::endl;
                          
                          }
                            for(int i (0); i<total_generator-1; i++)
                                                                 {
                          //std::cout << "leadSyz_Success:"<<vec[i] << std::endl;
                          Sublift.emplace_back(vec[i]);
                         
                         //std::cout << "leadSyz_Success:"<<vec[i] << std::endl;
                          //std::cout << "SubliftleadSyz_Success:"<<vec[i] << std::endl;
                          
                          }
                       syz_sum.emplace_back(vec[total_generator-1]);
                      
                         

            
                   
            
            ]]></code>
        </module>
      </defun>
      <connect-read port="library_name" place="place_library_name"/>
      <connect-read port="base_filename" place="place_base_filename"/>
      <connect-read port="input" place="place_input_GB"/>
      <connect-in port="s" place="place_control"/>
      <connect-out-many port="OUT" place="place_lead"/>
     
        <connect-out-many port="Sublift" place="place_SubLift"/>
    
       <connect-out port="syz_sum" place="left_init"/>
       <connect-out port="counter" place="place_counter"/>
     
    </transition>









     <!-- Transition 2: LIFT-->

      <transition name="LIFT">
        <defun>
     <require key="worker" mandatory="true"/>
    
     <in name="needed_library" type="string"/>
     <in name="base_filename" type="string"/>
     <in name ="lead" type = "string"/>
    
     <in name ="all_lead" type= "string"/>
     <in name ="input_name" type= "string"/>
 <out name="D" type ="control"/>
     <out name ="LIFT" type= "list"/>
    

             <module name="singular_template"
            require_function_unloads_without_rest="false"
            function="LIFT(input_name,lead,all_lead,LIFT,needed_library,base_filename,D)">
            <cinclude href="interface/template_interface.hpp" />
           <cinclude href="util-generic/dynamic_linking.hpp"/>
            <cinclude href="vector"/>
            <cinclude href="iostream"/>
            <cinclude href ="string"/>
            <cinclude href="list"/>
            <cinclude href="chrono"/>


            <code><![CDATA[
                  //  std::cout << "in singular _PetriNet_.._LIFT" << std::endl;
                   
                   std::tuple<std::vector<std::string>, int, long> out = RESOLVE_INTERFACE_FUNCTION(singular_template_LIFT)
                  (input_name,all_lead, lead, needed_library, base_filename);
                       

                       std::vector<std::string> vec = std::get<0>(out);
                       int total_generator = std::get<1>(out);
                      
                      //  std::cout << "#LIFT_Terms:"<< counter << std::endl;
                        
                         for(int i (0); i<vec.size(); i++)
                                                                 {
                         //std::cout << "LIFT_Success:"<<out.first[i] << std::endl;
                          LIFT.emplace_back(vec[i]);
                       
                         
                         
      
                    }
               
              // std::cout << "LIFT_COUNT_Parent:"<< N << std::endl;
              // std::cout << "LIFT_COUNT_Child:"<< E << std::endl;
              


// std::cout << "LIFT Duration: " << runtime << " milliseconds" << std::endl;
              

            ]]></code>
            </module>
               
   </defun>

  <connect-read port="needed_library" place="place_library_name"/> 
   <connect-read port="base_filename" place="place_base_filename"/>
  <connect-read port="input_name" place="place_input_GB"/>
   <connect-read port="all_lead" place="place_All_Lead"/>
  <connect-in port="lead" place="place_lead"/>
  <connect-out-many port="LIFT" place="place_Tau"/>




<connect-out port="D" place="LIFT_init_Remove"/>


  </transition> 
  
      


 <place name="LIFT_init_Remove" type="control">
 
</place>



<place name="Count_LIFT" type="int">
 <token>
        <value>0</value>
      </token>
    
</place>


<transition name="Count">
      <defun>
        <inout name="a" type="int"/>
        <in name="s" type="control"/>
        <module name="singular_template" function="count_LIFT(a,s)">
        <cinclude href="iostream"/>
        <code><![CDATA[
          a=a+1;
      //  std::cout <<"Count_LIFT: " << a << std::endl;
        ]]></code>
        </module>
        
      </defun>
      <connect-inout port="a" place="Count_LIFT"/>
      <connect-in port="s" place="LIFT_init_Remove"/>
     

    </transition>







 

 
















<!-- Transition 4: SubLIFT-->

      <transition name="SubLIFT">
        <defun>
     <require key="worker" mandatory="true"/>
    
     <in name="needed_library" type="string"/>
     <in name="base_filename" type="string"/>
     <in name ="all_lead" type= "string"/>
     <in name ="input_name" type= "string"/>
     <in name="place_Tau" type="string"/>
    
    
     <out name ="LIFT" type= "list"/>
     <out name ="SUBLIFT" type= "string"/>
    
             <module name="singular_template"
            require_function_unloads_without_rest="false"
            function="SUBLIFT(input_name,place_Tau,LIFT,all_lead,SUBLIFT,needed_library,base_filename)">
            <cinclude href="interface/template_interface.hpp" />
           <cinclude href="util-generic/dynamic_linking.hpp"/>
            <cinclude href="vector"/>
            <cinclude href="iostream"/>
            <cinclude href ="string"/>
            <cinclude href="list"/>
            <cinclude href="chrono"/>
            
               
                    
                

            <code><![CDATA[

             
                  //  std::cout << "in singular _PetriNet_.._SubLIFT" << std::endl;
                           
                 std::tuple<std::vector<std::string>, int, long> out = RESOLVE_INTERFACE_FUNCTION(singular_template_SUBLIFT)
                 (input_name,all_lead,place_Tau, needed_library, base_filename);
                       
                     std::vector<std::string> vec = std::get<0>(out);
                      int total_generator = std::get<1>(out);
                    
                     

                        
                         for(int i (0); i<vec.size(); i++)
                                                                 {
                         //std::cout << "SUBLIFT_Success:"<<out.first[i] << std::endl;
                          LIFT.emplace_back(vec[i]);
                          
                          // std::cout << "SubLIFT_IN_Place:" << vec[i]<< std::endl;
                          
                          
                       
                    
                         
      
                    }
           
              
                           
                
              // std::cout << "SubLIFT_COUNT_Parent:"<< N << std::endl;
              // std::cout << "SubLIFT_COUNT_Child:"<< E << std::endl;
              
                 


                    SUBLIFT = place_Tau;
                  //  std::cout << "SubLIFT_IN_Place:" << SUBLIFT << std::endl;
                  //std::cout << "SubLIFT_COUNT:"<< tau_count << std::endl; 





       
               
            ]]></code>
            
            </module>
               
   </defun>

  <connect-read port="needed_library" place="place_library_name"/> 
   <connect-read port="base_filename" place="place_base_filename"/>
  <connect-read port="input_name" place="place_input_GB"/>
   <connect-read port="all_lead" place="place_All_Lead"/>
  <connect-in port="place_Tau" place="place_Tau"/>
  <connect-out-many port="LIFT" place="place_Tau"/>
  <connect-out port="SUBLIFT" place="place_SubLift"/>


   
 
  
  </transition> 




  <place name="place_file_number" type="int">
 
</place>



<!-- Transition: RenameFIle -->
<transition name="Rename_File">
  <defun>
   <inout name ="n" type ="control"/>
  <in name="Sublift" type="string"/>
   
  
    <module name="singular_template" function="Rename_file(n,Sublift)">
     <cinclude href="interface/template_interface.hpp" />
  <cinclude href="util-generic/dynamic_linking.hpp"/>
  <cinclude href="iostream"/>
  <cinclude href="chrono"/>
    <code><![CDATA[

 output=input;
]]></code>
 </module>
    n=n+1;
 auto s  = RESOLVE_INTERFACE_FUNCTION(singular_template_Rename_File) (Sublift,n);
 

  </defun>
  <connect-in port="Sublift" place="place_SubLift"/>
 
  
    <connect-in port="n" place="place_file_number"/>

    <connect-out port="n" place="place_file_number"/>
</transition>




<place name="left_init" type="list">
 
</place>


    <transition name="Generate">
      <defun>
        <require key="worker" mandatory="true"/>
    
    
        <in name="a" type="string"/>
        <in name="s" type="list"/>
        <out name ="vec" type="list"/>
        <inout name="vec_size" type="unsigned long"/>
        <module name="singular_template" 
        require_function_unloads_without_rest="false"
         function="Generate(s,a,vec,vec_size)">
        
         <cinclude href="interface/template_interface.hpp" />
        <cinclude href="util-generic/dynamic_linking.hpp"/>
        <cinclude href="vector"/>
        <cinclude href="iostream"/>
        <cinclude href ="string"/>
        <cinclude href="list"/>
        <cinclude href="numeric"/> 
        <cinclude href="chrono"/>

        <code><![CDATA[
          
      
     



    using pnet_value = pnet::type::value::value_type;
    using pnet_list = std::list<pnet_value>;
         pnet_list temp_a;
        for (const auto& item : s)
        {
         
            temp_a.push_back(pnet::type::value::value_type(item));
        }
        temp_a.push_back(pnet::type::value::value_type(a));

        vec.push_back(temp_a);
    

           // Calculate the total number of elements in vec
           unsigned long total_elements = 0;

           // Iterate over each item in vec and count the size of each inner list
           for (const auto& variant_item : vec) {
               // Try to extract the list from the variant
               if (const auto* inner_list = boost::get<std::list<pnet_value>>(&variant_item)) {
                   total_elements += inner_list->size(); // Add the size of the inner list
               }
               // You can add more cases for other types, if necessary
           }
   
           // Set the size of vec to the calculated total number of elements
          vec_size = total_elements;
          std::cout << "vec_size :" << vec_size  << std::endl;

        ]]></code>
        </module>
      </defun>
   
      <connect-in port="s" place="left_init"/>
      <connect-out-many port="vec" place="left_init"/>
      <connect-in port="a" place="place_SubLift"/>
      <connect-in port="vec_size" place="place_vec_size"/>
      <connect-out port="vec_size" place="place_vec_size"/>
    </transition>


    <place name="place_vec_size" type="unsigned long">
    <token>
    <value>0UL</value>
  </token>

</place>
     







<place name ="place_StartTime" type ="long"/>

<transition name="Result">
  <defun>
    <in name="s" type="list"/>
    <out name="vec" type="list"/>
    <out name="start_time" type="long"/>
   
    <in name="vec_size" type="unsigned long"/>

    <module name="singular_template" function="result(s,vec,start_time,vec_size)">
      <cinclude href="interface/template_interface.hpp" />
      <cinclude href="util-generic/dynamic_linking.hpp"/>
      <cinclude href="iostream"/>
      <cinclude href="chrono"/>
      <code><![CDATA[
        auto computation_time = std::chrono::high_resolution_clock::now();
        auto duration = computation_time.time_since_epoch();
        start_time = std::chrono::duration_cast<std::chrono::nanoseconds>(duration).count();

        using pnet_value = pnet::type::value::value_type;
        using pnet_list = std::list<pnet_value>;

        pnet_list temp_a;
        
        // Copy elements from s to temp_a
        for (const auto& item : s)
        {
            temp_a.push_back(pnet::type::value::value_type(item));
        }

        // Append the new element 'a' to the list
  

        // Push the updated list to vec
        vec.push_back(temp_a);

        std::cout << "vec_size_in Result :" << vec_size  << std::endl;

      
      ]]></code>
    </module>

    <condition>
    ${vec_size} :eq: 20UL
    </condition>
  </defun>


  <connect-out port="start_time" place="place_StartTime"/>
  <connect-in port="s" place="left_init"/>
  <connect-out-many port="vec" place="place_sum_token"/>
  <connect-in port="vec_size" place="place_vec_size"/>

</transition>





 <place name="place_sum_token" type="list"/>
<place name="place_Final_Syz" type="string"/>





<!-- Transition 5: Reduce-->
    <transition name="Add1">
      <defun>
      <require key="worker" mandatory="true"/>
    
     <in name="library_name" type="string"/>
     <in name="base_filename" type="string"/>
        <out name="s" type="string"/>
        <in name="l" type="list"/>
        
        <in name="input" type="string"/>
     
       
     <module name="singular_template"
              		require_function_unloads_without_rest="false"
              		function="reduce(library_name, base_filename,input, s,l)">
          		<cinclude href="interface/template_interface.hpp" />
          		<cinclude href="util-generic/dynamic_linking.hpp"/>
              <cinclude href="iostream"/>
             <cinclude href="chrono"/>

          			<code><![CDATA[
std::vector<std::string> vec;
 for (const auto& elem : l) {
            auto ptr = boost::get<std::string>(&elem) ;
            std::string ss=*ptr;
            vec.push_back(ss);
          }
              
              
						 auto result  = RESOLVE_INTERFACE_FUNCTION(singular_template_reduce)(input,vec,library_name, base_filename
							); 
                s = result.first;
        
            std::cout << "Reduce:" << s << std::endl;
                 

//std::cout << "Reduce Duration: " << runtime << " milliseconds" << std::endl;

            		]]></code>
                 
        		</module>
                 
     
      </defun>

      <connect-read port="library_name" place="place_library_name"/> 
      <connect-read port="base_filename" place="place_base_filename"/>
      <connect-read port="input" place="place_input_GB"/>
    
     
      <connect-in port="l" place="place_sum_token"/>
     
     
   
      <connect-out port="s" place="place_Syz"/>
  
    </transition> 



   
 <!-- Transition: EndTime -->
<transition name="EndTime_Syz">
    <defun>
        <in name="start_time" type="long"/>
        <inout name="computed_output" type="string"/>
      
      
         <module name="singular_template" function="EndTime_Syz(start_time,computed_output)">
         <cinclude href="interface/template_interface.hpp" />
      <cinclude href="util-generic/dynamic_linking.hpp"/>
      <cinclude href="iostream"/>
      <cinclude href="chrono"/>
        <code><![CDATA[
                auto computation_time = std::chrono::high_resolution_clock::now();
                auto duration = computation_time.time_since_epoch();
                long current_time = std::chrono::duration_cast<std::chrono::nanoseconds>(duration).count();
               long end_timer = current_time - start_time; // Calculate elapsed time
              
                std::cout << "Calculate Syz: = " << end_timer << " nanoseconds" << std::endl;
            ]]></code>
         </module>
     
    </defun>
    
    <connect-in port="start_time" place="place_StartTime"/>
    <connect-in port="computed_output" place="place_Syz"/>
   
    <connect-out port="computed_output" place="place_Final_Syz"/>
   
    
</transition>











  </net>
</defun>