

//signature_function.hpp

NO_NAME_MANGLING
std::string singular_template_Generate (std::string const&,
                                      , std::string const&
                                      , std::string const&
									  , std::string const&
                                      );


//Implementation.cpp
NO_NAME_MANGLING


std::string  singular_template_Generate(std::string const& res
										, std::string const& syz
										, std::string const& needed_library
            							, std::string const& base_filename)
{
	init_singular (config::singularLibrary().string());
	load_singular_library(needed_library);
	  // Deserialize input data
    std::pair<int, lists> input;
    std::pair<int, lists> Syz;
   
    
    //auto start_deserialize = std::chrono::high_resolution_clock::now();
    input = deserialize(res, ids);
    Syz = deserialize(syz, ids);
    
   


    ScopedLeftv args(input.first, lCopy(input.second));
    ScopedLeftv arg(args,Syz.first, lCopy(Syz.second));
    
    
    
    // Call Singular procedure
    std::pair<int, lists> out;
    std::string function_name = "Generate_GPI";
	out = call_user_proc(function_name, needed_library, args);
	out_filename = serialize(out.second, base_filename);
	return out_filename;
}


<!-- Transition 11: Generate-->
<transition name="Generate">
  <defun>

  <in name="library_name" type="string"/>
     <in name="base_filename" type="string"/>
    <inout name="len" type="int"/>
    <in name="syz" type="string"/>
    <in name="res" type="string"/>
    <out name="Res" type ="string"/>
    <in name="input" type="string"/>
    <in name="sumTime" type="long"/>
   
    <out name ="Input" type="string"/>
    <out name="c" type ="control"/>
    
    <module name="singular_template" function="Generate(res,sumTime, Res, input,Input,len, c,syz)">
      <cinclude href="interface/template_interface.hpp" />
      <cinclude href="util-generic/dynamic_linking.hpp"/>
       <cinclude href="iostream"/>
      <code><![CDATA[
       //std::cout << "Generate_Input:"<<input<< std::endl;
       //std::cout << "Generate_Syz:"<<syz<< std::endl;
       //std::cout << "Generate_control:"<<c<< std::endl;
        Res= RESOLVE_INTERFACE_FUNCTION(singular_template_Generate)(res,syz,library_name, base_filename
							); 
       Input=syz;
       
        c={};
      len=len-1;
      std::cout << "Iterative_level_syz: "<<len<< std::endl;
      ]]></code>
    </module>
    
     

  </defun>
   <connect-read port="library_name" place="place_library_name"/> 
    <connect-read port="base_filename" place="place_base_filename"/>
  <connect-in port="input" place="place_input_GB"/>
  <connect-in port="res" place="place_Res"/>
  <connect-in port="syz" place="place_Syz"/>
  <connect-out port="Input" place="place_input_GB"/>
  <connect-out port="c" place="place_control"/>
  <connect-out port="Res" place="place_Res"/>
  <connect-inout port="len" place="place_length_Res"/>
 <connect-in port="sumTime" place="place_sum_runtime"/>
  
</transition>


//code in singular
//Summation function for GPI-Space

proc Generate_GPI(token input, token Tok){
 def res=input.data[1];
 def Syz=Tok.data[1];
 list L=res;
 list L1;
 for(int i=1; i<=size(L); i++){
  L1[i]=L[i];
 }
 L1[size(L)+1]=Syz;
 


   
 
  
    token output;
    output.fieldnames = list("generators","list_Syz_matrices");
    output.data[1] = L1;
    output.data[2]=size(L1);
   
  
    return(output);
}