//////////////////////////////////////////////////////////////////////////////
version=" ";
category="Noncommutative";
info="
LIBRARY: sresforextalg.lib     Schreyer's algorithm for modules over the exterior algebra
AUTHORS: Ramesh, L.,           ramesh@mathematik.uni-kl.de   

OVERVIEW:
Procedures for and involving computing Schreyer resolution of modules over the exterior algebra

PROCEDURES:
schreyerSyzExt(m);            (refined) Schreyer syzygy of a module over the exterior algebra 
sresExt(m,p);                 free resolution of module m over the exterior algebra using refined Schreyer alg        
mresExt(m,p);                 minimal free resolution of module m over the exterior algebra using refined Schreyer alg
sheafCohBGGsres(M,l,h)        cohomology of twists of the coherent sheaf F on P^n
                              associated to coker(M). The range of twists is determined by l,h.
";

LIB "nctools.lib"; // for ncalg
LIB "matrix.lib"; // for submat
LIB "sheafcoh.lib"; // for displayCohom
//LIB "tst.lib"; tst_init(); tst_ignore("// ** loaded "); tst_ignore("// ** _ is no standard basis");

///////////////////////////////////////////////////////////////////////////////

proc leadmonomial_nc(def s) 
{
  int e;
  poly m;

  if(typeof(s) == "vector"){
    e=leadexp(s)[nvars(basering)+1];
    m=leadmonom(s)[e,1];
  }
  if(typeof(s) == "poly"){
    m=leadmonom(s);
   }
  return(m);
}

proc leadterm(def s)
{
  int e;
  poly m;

  if(typeof(s) == "vector"){
    e=leadexp(s)[nvars(basering)+1];
    m=lead(s)[e,1];
  }
  if(typeof(s) == "poly"){
    m=lead(s);
   }
  return(m);
}
















proc lcm_(poly v, poly w)
{
    string strv = string(v);
    string strw = string(w);
    int sizev = size(strv);
    int sizew = size(strw);
    int n = nvars(basering);
    int i;
    intvec expv, expw;
    poly ans = 1;
    if (strv[sizev] == "2" && strw[sizew] == "2"){
      ans = 0;
      return(ans); // not sure about type
    }
    else{
      if (strv[sizev] != "2" && strw[sizew] != "2"){
        expv = leadexp(v);
        expw = leadexp(w);
        for (i=1; i<=n; i++){
          if (expv[i]==1 || expw[i]==1){
            ans = ans*var(i);
          }
        }
        return(ans);
      }
      else {
        if (strv[sizev] == "2"){
          expw = leadexp(w);
          expv = leadexp(v);
          for (i=1; i<=n; i++){
            if (expv[i] == 2){
              ans = ans*(var(i))^2;
            }
            else{
              if (expw[i] == 1){
                ans = ans*var(i);
              }
            }
          }
        }
        else{
          expw = leadexp(w);
          expv = leadexp(v);
          for (i=1; i<=n; i++){
            if (expw[i] == 2){
              ans = ans*(var(i))^2;
            }
            else{
              if (expv[i] == 1){
                ans = ans*var(i);
              }
            }
          }
        }
        return(ans);
      }
    }
}


proc lead_syz_(module m)
{
  int r = size(m);
  int n = nvars(basering);
  module M = std(freemodule(r));
  vector pi, pj, t, s;
  poly Li, Lj, mji;
  int i, j, k, expi, expj;
  module temp_mod_1, temp_mod_2;
  module lead_mod; //this is what we will return

  for(i=2; i<=r; i++){
    pi = m[i];
    for(j=1; j<i; j++){
      pj = m[j];
      expi = leadexp(pi)[n+1];
      expj = leadexp(pj)[n+1];
      if(expi == expj){
        Li = leadmonomial_nc(pi);
        Lj = leadmonomial_nc(pj);
        mji = lcm_(Lj,Li)/leadterm(pi);
        t = mji*M[i];
        for (k=1;k<=size(lead_mod);k++){
          temp_mod_1 = lead_mod[k];
          attrib(temp_mod_1, "isSB", 1);
          if (NF(t, temp_mod_1)==0){
            t = 0;
            break;
          }
          else{
            temp_mod_2 = t;
            attrib(temp_mod_2, "isSB", 1);
            if(NF(lead_mod[k], temp_mod_2)==0){
              lead_mod = delete(lead_mod, k);
              k = k-1;
            }
          }
        }
        if(t != 0){
          lead_mod[size(lead_mod)+1] = t;
        }
      }
    }
  }
  return(lead_mod);
}









proc lead_syz_GpI(token Token) 
"USAGE: leadsyz_GpI(Token); Token token
RETURN: a token LLT containing a list of leading syzygies
NOTE: The types token are defined . This procedure is 
intended to be called as a transition procedure inside the
worker process (that is, the "inner" instances of SINGULAR).
"
{
  
  def f= Token.data[1];
  int counter;
 
  token LLT;
  int k;
 
  def LT;
 
   LT = lealead_syz_dSyz(f);
   int ro=size(f);
   counter=1;
 
   
// string path = "/home/gnawali/gspc-syz/example_dir/temp/";  // Ensure the path ends with a "/"
// string filename = "Leadsyz.ssi";
// link l = "ssi:w " + path + filename;

// write(l, LT, "SecondSyzModule");
// close(l);
   
   
  //list J=tok.data[1];
   //int level=size(J);


 

  int r = size(LT);
  for (k = 1; k <=r; k++) {
    token Ld;
    Ld.fieldnames = list("generator", "Lead_Syz_Sparse_matrix");  
    matrix sM[ro][size(LT)];
    vector s_lift = LT[k];
    
    int l_k = leadexp(s_lift)[nvars(basering) + 1];

    sM[l_k, k] = leadcoef(s_lift) * leadmonomial(s_lift);
    
    //print(sM);
    Ld.data[1]= s_lift;
    //print(s_lift);
    Ld.data[2]= sM;
     //print("matrix");
    //print(Ld.A);

    //print("row");

    Ld.data[3] = l_k;
    //print(Ld.p);

    //print("q:column");
    Ld.data[4]= k;

    Ld.data[5]=LT;
    Ld.data[6]=counter;
    Ld.data[7]=counter;
    LLT.fieldnames[k] = "generator";  
    LLT.data[k] = Ld; 

  }
  
      LLT.fieldnames[size(LLT.fieldnames) + 1] = "total_number_generator";  
      LLT.data[size(LLT.data) + 1] = r;  
    return (LLT);  
}


