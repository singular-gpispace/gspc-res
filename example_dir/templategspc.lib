///////////////////////////////////////
version="version templategspc.lib 0.2 Mar_2024 ";
category="Algebraic geometry";
info="
LIBRARY: templategspc.lib  template library for  GPI-Space interface on Singular

OVERVIEW:
This library contains SINGULAR template procedures for a Singular/GPI-Space framework containing 2 places and 1 transition.

TYPES:
configToken          general configuration token type
gspcConfigToken      configuration token for GPI-Space
templateConfigToken  configuration token for the transition procedure

PROCEDURES:
configure_gspc()                               generates standard config token for GPI-Space
configure_template()                           generates standard config token for the transition procedure
generateIOTokenTypes(configToken)              register the user-defined types for input and output
gspc_template(list,configToken,configToken)    interface of the template framework in Singular
";

proc mod_init()
{
    //Singular does not support fieldname containing underscore
       // LIB "libSINGULAR-template-module.so";
       LIB "/scratch/gnawali/Try/gspc-res/build_dir/src/libSINGULAR-template-module.so";
    newstruct("configToken", "string tokentype, def options");
    newstruct("gspcConfigToken", "string tmpdir, string nodefile, int procspernode, string rifstrategy, string rifstrategyparameters, string loghost, int logport, string loghostfile");
    newstruct("templateConfigToken", " string neededLibrary, string functionName");
    newstruct("token", "list fieldnames, list data");
    //newstruct("Toknlift", "vector a, vector b"); 

}

proc configure_gspc()
"USAGE: configure_gspc()
RETURN: a configToken containing a gspcConfigToken with the standard configuration for GPI-Space
"
{
    gspcConfigToken gc;
    gc.rifstrategy = "ssh";
    configToken ct;
    ct.tokentype = "gspcConfigToken";
    ct.options = gc;
    return(ct);
}

proc configure_template()
"USAGE: configure_template()
RETURN: a configToken containing a templateConfigToken with the standard
           configuration for the template pattern.
"
{
    templateConfigToken tc;
    configToken ct;
    ct.tokentype = "templateConfigToken";
    ct.options = tc;
    return(ct);
}

static proc gspc_template(list l, configToken gc, configToken pc)
{
    //Parse driver options
    string driver_opts;
    if ((typeof(gc.options) != "gspcConfigToken") || (typeof(pc.options) != "templateConfigToken"))
    {
        ERROR("wrong config token types");
    }

    //Parse rifstrategy and rifstrategy-parameters
    driver_opts = driver_opts + "--rif-strategy " + gc.options.rifstrategy;
    if ( gc.options.rifstrategyparameters != "")
    {
        driver_opts = driver_opts + " --rif-strategy-parameters " + gc.options.rifstrategyparameters; 
    }
    
    //Parse worker topology
    driver_opts = driver_opts + " --topology " + "worker:" + string(gc.options.procspernode);

    //Parse nodefile
    driver_opts = driver_opts + " --nodefile " + gc.options.nodefile;

    //Parser loghost and logport
    if (gc.options.logport != 0) // logging requested
    { 
        if (gc.options.loghost == "") // no hostname given, so read from file
        {
            if (gc.options.loghostfile == "")
            {
                ERROR("logging requested, no loghost and no loghostfile given");
            }
            string loghost = read(gc.options.loghostfile);
            if ((loghost == "") || (loghost == newline))
            {
                ERROR("no hostname in loghostfile");
            }
            if (loghost[size(loghost)] == newline) // delete trailing LF
            {
                loghost = loghost[1..(size(loghost)-1)];
            }
            gc.options.loghost = loghost;
        }
        driver_opts = driver_opts + " --log-host " + gc.options.loghost, " --log-port ", string(gc.options.logport);
    }

    if (system("getenv", "LD_LIBRARY_PATH") != "")
    {
        driver_opts = driver_opts + " --worker-env-copy-variable " + "LD_LIBRARY_PATH";
    }

    //Starting to parse workflow options
    string workflow_opts;

    //Parse N
    //workflow_opts = "--N " + string(N);

    //Parse basefilename
    string tmpdir;
    if (gc.options.tmpdir[1] == "/")
    {
        tmpdir = gc.options.tmpdir;
    }
    else
    {
        tmpdir = system("getenv", "PWD") + "/" + gc.options.tmpdir;
    }
    string basefilename = tmpdir + "/";
    workflow_opts =  workflow_opts + " --basefilename " + basefilename;

    //Parse input
    link lin;
    int N=1;
    for(int i = 1; i<=N; i++)
    {
        lin = "ssi:w " + basefilename + "input";
        write(lin, l[i]);
        close(lin);
    }
    workflow_opts = workflow_opts + " --input " + "input";

    //Parse libraryname
    string loadlib;
    if (pc.options.neededLibrary[1] == "/")
    {
        loadlib = pc.options.neededLibrary;
    }
    else
    {
        loadlib = system("getenv", "PWD") + "/" + pc.options.neededLibrary;
    }
    workflow_opts = workflow_opts + " --libraryname " + loadlib;

   
    
    string all_opts = driver_opts + " " + workflow_opts;
   
    def sm_result = sggspc_template(all_opts);


    return(sm_result);
}


proc ext_elimination_(module m, module syz_mod)
{
  //note m is NOT lifted.
  int r = size(m);
  int n = nvars(basering);
  module ans_mod, temp_I;
  
  matrix needed_mat = submat(matrix(syz_mod), 1..r, 1..size(syz_mod));
  ans_mod = module(needed_mat);
  int i,j,k;

  for(i=1;i<=size(ans_mod);i++){
    for(j=1;j<=nrows(matrix(ans_mod[i]));j++){
      for(k=1;k<=n;k++){
        temp_I = var(k)^2;
        attrib(temp_I, "isSB", 1);
        if ((NF(ans_mod[i][j], temp_I) == 0) && ans_mod[i][j] != 0){
          ans_mod[i] = ans_mod[i] - ans_mod[i][j]*gen(j);
          break;
        }
      }
    }
    if(ans_mod[i] == 0){
        ans_mod = delete(ans_mod, i);
        i = i-1;
    }
  }
  return(ans_mod);
}




proc gspc_template_SchRes( module I, int Row,int Col, configToken gc)
{
    configToken ct = configure_template();
    ct.options.neededLibrary = "templategp.lib";
    ct.options.functionName = "schreyerSyzExt";
  
    int r= size(I);
    // print("Row=");
    // print(Row);
    // print("Col");
    // print(Col);
    //intvec primeiv = primeList(I, nb_prime);
    list inputlists;
    token t;
    for (int i = 1; i <=1; i++)
    {
        t.fieldnames = list("generators","Input");
        t.data[1] = I;
        t.data[2] = r;
        inputlists[i] = t;
    }
      rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
//  int t0=rtimer;
  int t1=rtimer;
    def re = gspc_template(inputlists, gc, ct);
//        rtimer-t0;
// print("timer");
    def inputRing = basering;
    // Access the first element in the list
    def resultToken = re[1];
    
   

        def resultRing = resultToken.r_data;
       setring resultRing;
    // Extract the data from resultToken
    def Result = resultToken.data;

 
 matrix Mr=matrix(Result[2]);

 setring inputRing;
 matrix Mr=fetch(resultRing,Mr);
//  print("Mr=");
//  print(transpose(Mr));
matrix Ir=matrix(I);
//   print(I);
//   print("Final product");

//   print(Ir*Mr);
  matrix subM=submat(Ir,1..Row,1..Col);// should know generators of std of given module, here 6 generators
//   print("input=");
//   print(subM);
//   print("final");
  matrix extM=ext_elimination_(subM,Mr);
    rtimer-t1;
    print("timer including");
  matrix extM_t=transpose(extM);
   print("Syzygy");
  print(extM);
  matrix subM_t=transpose(subM);

//  print(subM*extM);
 print("Final produt");
 print(extM_t*subM_t);
// def Re=ext_elimination_(I,Result[2]);


    // setring inputRing;
//  def Result=fetch(resultRing,Result);
//  print("After fetch");
//   print(Result);
    return("Result");
}