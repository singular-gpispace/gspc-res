def m=read("ssi:r temp/schipp_137122_1722874432463313577");
;
quit;
quit;
;
ring R=0, x, dp;
smatrix s[2][4];
s[2,3]=x;
s;
link l="ssi:w Smatrix.ssi";
l;
write(l,s,"SparseMatrix");
close(l);
read(l);
quit;
;
quit;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_25806_1736698215488372479";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
link l="ssi:r temp/schipp_240862_1737048742843708911";
def m=read(l);
m;
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
link l="ssi:r temp/schipp_240868_1737048742825210267";
def m=read(l);
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
link l="ssi:r temp/schipp_264027_1737053047865109720";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
link l="ssi:r temp/schipp_264962_1737053284928385845";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_326815_1737109766608777385";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
m.data[6];
quit;
link l="ssi:r temp/schipp_327534_1737109911734542349";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_337461_1737112126479580894";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
m.data[6];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_469299_1737217276234718930";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
matrix M1[6][13]=m.data[2];
M1;
re;
J;
setring re;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_477822_1737219247716100783";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/SchFrame.ssi";
def m=read(l);
m;
quit;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
quit;
link l="ssi:r temp/SubLIFT.ssi";
m;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
m0=read(l);
def m0=read(l);
m0;
def m1=read(l);
m1;
quit;
m1;
quit;
m1;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
def m6=read(l);
def m6=read(l);
m6;
quit;
m6;
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
quit;
m5;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
def m6=read(l);
m6;
def m7=read(l);
m7;
def m8=read(l);
m8;
def m9=read(l);
m9;
def m10=read(l);
m10;
def m11=read(l);
m11;
def m12=read(l);
m12;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
link l="ssi:r temp/schipp_717415_1737380846819062161";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
print(m.data[2]);
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Leadsyz.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
quit;
quit;
;
link l="ssi:r temp/Leadsyz.ssi";
m;
def m=read(l);
m;
quit;
m;
;
;
link l="ssi:r temp/lead_syz_extr.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
quit;
;
link l="ssi:r temp/Leadsyz.ssi";
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
quit;
;
link l="ssi:r temp/lead_syz_extr.ssi";
def m1=read(l);
m1;
m2;
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,60);
c;
rtimer-t;
quit;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
             kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
   print("C=");
   print(C);
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,583);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
             kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
   print("C=");
   print(C);
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,600);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
             kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
  //  print("C=");
  //  print(C);
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,4200);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
             kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
  //  print("C=");
  //  print(C);
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,3300);
c;
rtimer-t;
quit;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
             kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
  //  print("C=");
  //  print(C);
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,1749);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
             kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
  //  print("C=");
  //  print(C);
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,1200);
c;
rtimer-t;
quit;
;
link l="ssi: r temp/input";
def m=read(l);
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/scratch/gnawali/Try/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   string command;
   string file_k;
   link l;
    while(k <= N) {
         file_k = string(k) + ".ssi";  
         l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
            command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
             kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
  //  print("C=");
  //  print(C);
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
} 
 rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,7500);
c;
rtimer-t;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
