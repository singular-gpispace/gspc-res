def m=read("ssi:r temp/schipp_137122_1722874432463313577");
;
quit;
quit;
;
ring R=0, x, dp;
smatrix s[2][4];
s[2,3]=x;
s;
link l="ssi:w Smatrix.ssi";
l;
write(l,s,"SparseMatrix");
close(l);
read(l);
quit;
;
quit;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_25806_1736698215488372479";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
;
quit;
;
link l="ssi:r temp/schipp_240862_1737048742843708911";
def m=read(l);
m;
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
link l="ssi:r temp/schipp_240868_1737048742825210267";
def m=read(l);
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
link l="ssi:r temp/schipp_264027_1737053047865109720";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
link l="ssi:r temp/schipp_264962_1737053284928385845";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_326815_1737109766608777385";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
m.data[6];
quit;
link l="ssi:r temp/schipp_327534_1737109911734542349";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_337461_1737112126479580894";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
m.data[6];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_469299_1737217276234718930";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
matrix M1[6][13]=m.data[2];
M1;
re;
J;
setring re;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/schipp_477822_1737219247716100783";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/SchFrame.ssi";
def m=read(l);
m;
quit;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
quit;
link l="ssi:r temp/SubLIFT.ssi";
m;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
m0=read(l);
def m0=read(l);
m0;
def m1=read(l);
m1;
quit;
m1;
quit;
m1;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
def m6=read(l);
def m6=read(l);
m6;
quit;
m6;
quit;
;
link l="ssi:r temp/SubLIFT.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
quit;
m5;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
def m6=read(l);
m6;
def m7=read(l);
m7;
def m8=read(l);
m8;
def m9=read(l);
m9;
def m10=read(l);
m10;
def m11=read(l);
m11;
def m12=read(l);
m12;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
link l="ssi:r temp/schipp_717415_1737380846819062161";
def m=read(l);
m.r_data;
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
print(m.data[2]);
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
;
quit;
;
quit;
quit;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Leadsyz.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
quit;
quit;
;
link l="ssi:r temp/Leadsyz.ssi";
m;
def m=read(l);
m;
quit;
m;
;
;
link l="ssi:r temp/lead_syz_extr.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
quit;
;
link l="ssi:r temp/Leadsyz.ssi";
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
quit;
;
link l="ssi:r temp/lead_syz_extr.ssi";
def m1=read(l);
m1;
m2;
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
quit;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
def m6=read(l);
m6;
def m7=read(l);
m7;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/295.ssi";
def m=read(l);
m;
def nr=m.data;
def nr=m.r_data;
setring nr;
m.data;
;
link L="ssi:r temp/296.ssi";
def m=read(L);
def Nr=m.r_data;
setring Nr;
m.data[2];
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def nr=m.r_data;
quit;
;
quit;
quit;
;
def l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def l1="ssi:r temp/Reduce.ssi";
def m4=read(l1);
m4;
def m5=read(l1);
m5;
def m6=read(l1);
quit;
quit;
quit;
link l="ssi:r tem/Reduce.ssi";
def m=read(l);
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m6=read(l);
m6;
def m9=read(l);
m9;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
link l="ssi:r temp/7.ssi";
def m1=read(l);
m1;
def nr=m1.r_data;
setring nr;
m.data[2];
m1.data[2];
quit;
ring R=0, (x),dp;
smatrix C=0;
smatrix C=smatrix(0);
smatrix C=vector(0);
C;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
def m6=read(l);
m6;
def m7=read(l);
m7;
def m8=read(l);
m8;
def m9=read(l);
m9;
def m10=read(l);
m10;
def m11=read(l);
m11;
def m12=read(l);
m12;
quit;
quit;
link l="ssi:r temp/Reduce.ssi";
def m12=read(l);
m12;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
def m4=read(l);
m4;
def m5=read(l);
m5;
def m6=read(l);
m6;
def m7=read(l);
m7;
def m8=read(l);
m8;
def m9=read(l);
m9;
def m10=read(l);
m10;
def m11=read(l);
m11;
def m12=read(l);
m12;
def m13=read(l);
m13;
def m14=read(l);
m14;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/Reduce.ssi";
def m=read(l);
m.r_data;
def nr=m.r_data;
m;
def m1=read(l);
m1;
def m2=read(l);
m2;
def m3=read(l);
m3;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    smatrix sM;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          smatrix sM = t.data[2];
          write(l0,sM,"sM");
          setring inputRing;
           sM = fetch(nr, sM);
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
                //  kill(nr);
                 system("rm " + path1 + file_k);
           } else {
                  k=k+1;
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
token t;
token t0;
tt0=m;
t0=m;
t0;
smatrix C=Add_GPI(t0,70);
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    smatrix sM;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          smatrix sM = t.data[2];
          write(l0,sM,"sM");
          setring inputRing;
           sM = fetch(nr, sM);
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
                //  kill(nr);
                 system("rm " + path1 + file_k);
           } else {
                  k=k+1;
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
smatrix C=Add_GPI(t0,70);
ring R = 0, (w, x, y, z), (dp, c);
ideal I = w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z;
// Create a token
token t;
t.fieldnames = list("generators", "Input");
t.data[1] = I;  // Ideal I
t.data[2] = size(I);  // Size of the ideal
// Now call Add_GPI with the token and N
smatrix C = Add_GPI(t, 70);
;
kill R;
R:
;
kill ring;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module sM;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module sM = t.data[2];
          write(l0,sM,"sM");
          setring inputRing;
           sM = fetch(nr, sM);
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
                //  kill(nr);
                 system("rm " + path1 + file_k);
           } else {
                  k=k+1;
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
ring R = 0, (w, x, y, z), (dp, c);
ideal I = w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z;
// Create a token
token t;
t.fieldnames = list("generators", "Input");
t.data[1] = I;  // Ideal I
t.data[2] = size(I);  // Size of the ideal
// Now call Add_GPI with the token and N
module C = Add_GPI(t, 70);
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
                //  kill(nr);
                 system("rm " + path1 + file_k);
           } else {
                  k=k+1;
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
ring R = 0, (w, x, y, z), (dp, c);
ideal I = w^2 - x*z, w*x - y*z, x^2 - w*y, x*y - z^2, y^2 - w*z;
// Create a token
token t;
t.fieldnames = list("generators", "Input");
t.data[1] = I;  // Ideal I
t.data[2] = size(I);  // Size of the ideal
// Now call Add_GPI with the token and N
smatrix C = Add_GPI(t, 70);
quit;
;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
                //  kill(nr);
                 system("rm " + path1 + file_k);
           } else {
                  k=k+1;
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
def l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
smatrxi c=Add_GPI(m,40);
smatrix  c=Add_GPI(m,40);
smatrix  c=Add_GPI(m,40);
quit;
;
link l="ssi:r temp/input";
def m=read(l);
defnr=m.r_data;
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
                //  kill(nr);
                //  system("rm " + path1 + file_k);
           } else {
                  k=k+1;
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
smatrix c[5][6]=Add_GPI(m,40);
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   int max_steps = 10;  // Stop after 10 iterations
    int step_count = 0;
    while(k <= N&& step_count < max_steps) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
                //  kill(nr);
                //  system("rm " + path1 + file_k);
           } else {
                  k=k+1;
                  step_count = step_count + 1;  // Increase step count
                   // **Print C at the last iteration**
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
smatrix c=Add_GPI(m,41);
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 10;  // Limit to 10 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 10 iterations.");
            break;  // Exit the loop after 10 iterations
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // Rename processed file to avoid re-processing
            system("mv " + path1 + file_k + " " + path1 + file_k + ".processed");
        }
        k = k + 1;
        step_count = step_count + 1;  
        // **Print C at the last iteration**
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
quit;
link l="ssi:r temp/input
link l="ssi:r temp/input";
link l="ssi:r temp/input";
;
quit;
quit;
exit;
link l="ssi:r temp/input";
def m=read(l);
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 10;  // Limit to 10 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 10 iterations.");
            break;  // Exit the loop after 10 iterations
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // **system() call commented out**
            // system("mv " + path1 + file_k + " " + path1 + file_k + ".processed");
        }
        k = k + 1;
        step_count = step_count + 1;  
        // **Print C at the last iteration**
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
smatrix c=Add_GPI(m,40);
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 10;  // Limit to 10 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 10 iterations.");
            break;  // Exit the loop after 10 iterations
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // **system() call commented out**
            // system("mv " + path1 + file_k + " " + path1 + file_k + ".processed");
        }
        k = k + 1;
        step_count = step_count + 1;  
        // **Print C at the last iteration**
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 40;  // Limit to 10 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 10 iterations.");
            break;  // Exit the loop after 10 iterations
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // **system() call commented out**
            // system("mv " + path1 + file_k + " " + path1 + file_k + ".processed");
        }
        k = k + 1;
        step_count = step_count + 1;  
        // **Print C at the last iteration**
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
m;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 40;  // Limit to 10 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 10 iterations.");
            break;  // Exit the loop after 10 iterations
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // **system() call commented out**
            // system("mv " + path1 + file_k + " " + path1 + file_k + ".processed");
        }
        k = k + 1;
        step_count = step_count + 1;  
        // **Print C at the last iteration**
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
smatrix c=Add_GPI(m,40);
quit;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 40;  // Limit to 40 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 40 iterations.");
            break;  // Exit the loop after 40 iterations
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            M = t.data[2];  // Here, M is being assigned from the data read
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // **system() call commented out**
            // system("mv " + path1 + file_k + " " + path1 + file_k + ".processed");
        }
        k = k + 1;
        step_count = step_count + 1;  
        // **Print C at the last iteration**
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
smatrix c=Add_GPI(m,40);
def c0=Add_GPI(m,34);
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 40;  // Limit to 40 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 40 iterations.");
            break;  // Exit the loop after max steps
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // Execute the shell command to remove the file after processing
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
        }
        k = k + 1;
        step_count = step_count + 1;  
        // Print C at the last iteration or after max steps
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
smatrix c=Add_GPI(m,40);
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
  
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
def c=Add_GPI(m,40);
c;
quit;
;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 40;  // Limit to 40 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 40 iterations.");
            break;  // Exit the loop after max steps
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // Execute the shell command to remove the file after processing
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
        }
        k = k + 1;
        step_count = step_count + 1;  
        // Print C at the last iteration or after max steps
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
smatrix re= Add_GPI(input,40);
re;
rtimer-t;
print("timer");
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
smatrix c= Add_GPI(input,40);
c;
rtimer-t;
print("timer");
link l="ssi:r temp/input";
defm=read(l);
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    string filename = "Reduce.ssi";
    link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  
    module M;
    int first_time = 0;  
    int k = 1;
    int max_steps = 40;  // Limit to 40 iterations
    int step_count = 0;
    while (k <= N) 
    {
        if (step_count >= max_steps) 
        {
            print("Loop stopped after 40 iterations.");
            break;  // Exit the loop after max steps
        }
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
            def t = read(l);  
            close(l);  
            def nr = t.r_data;
            setring nr;
            module M = t.data[2];  
            setring inputRing;
            M = fetch(nr, M);  
            smatrix sM = M;    
            write(l0, sM, "sM");
            if (first_time == 0) 
            {  
                write(l0, first_time, "first_time"); 
                C = sM;       
                first_time = 1;  
            } 
            else 
            {
                C = C + sM;  
            } 
            // Execute the shell command to remove the file after processing
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
        }
        k = k + 1;
        step_count = step_count + 1;  
        // Print C at the last iteration or after max steps
        if (step_count == max_steps || k > N) 
        {
            print("Final C after last iteration:");
            print(C);
        }
    }
    close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
smatrix c= Add_GPI(input,40);
c;
rtimer-t;
print("timer");
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
smatrix c= Add_GPI(m,40);
c;
rtimer-t;
print("timer");
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
smatrix re= Add_GPI(m,7080);
re;
rtimer-t;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
smatrix c= Add_GPI(m,7080);
c;
rtimer-t;
c;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,72420);
c;
rtimer-t;
quit;
proc Add_GPI(int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = 1;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,26680);
c;
rtimer-t;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(26680);
c;
rtimer-t;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,27000);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,27000);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
  print("killer smatrix");
  print(C);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
proc ADD_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
  print("killer smatrix");
  print(C);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= ADD_GPI(m,27000);
c;
rtimer-t;
C;
link l="ssi:r temp/schipp_339414_1742674322091438319";
def m1=read(l);
def nr=m1.r_data;
setring nr;
m1.data;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
  print("killer smatrix");
  print(C);
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,600);
c;
rtimer-t;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }
            // Print C only when k == N (final iteration)
        if (k == N) 
        {
            print("Final C after last iteration (k == N):");
            print(C);  // Print the final matrix C
        }    
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,600);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= ADD_GPI(m,600);
c;
rtimer-t;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,600);
c;
rtimer-t;
   proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    module C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }
            // Print C only when k == N (final iteration)
        if (k == N) 
        {
            print("Final C after last iteration (k == N):");
            print(C);  // Print the final matrix C
        }    
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
m;
m.data;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,600);
c;
rtimer-t;
quit;
quit;
;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }
            // Print C only when k == N (final iteration)
        if (k == N) 
        {
            print("Final C after last iteration (k == N):");
            print(C);  // Print the final matrix C
        }    
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,27000);
c;
rtimer-t;
quit;
quit;
quit;
quit;
;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }
            // Print C only when k == N (final iteration)
        if (k == N) 
        {
            print("Final C after last iteration (k == N):");
            print(C);  // Print the final matrix C
        }    
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,72900);
c;
rtimer-t;
quit;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
      setrring inputRing;
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
           
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,600);
c;
rtimer-t;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,600);
c;
rtimer-t;
quit;
quit;
;
proc Add_GPI(int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } else {
                  k=k+1;
                 
          }    
    }
  // close(l0);
 print("killer smatrix");
 print(C);
   token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = 1;   
    output.data[3] = ncols(C);  
    return(output);
}
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,7500);
c;
rtimer-t;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
    while(k <= N) {
        string file_k = string(k) + ".ssi";  
        link l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              
            string command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
m.data;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,7500);
c;
rtimer-t;
quit;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   link l;
   string command ;
   string file_k;
    while(k <= N) {
        file_k = string(k) + ".ssi";  
        l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
             command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
            kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,72900);
c;
rtimer-t;
quit;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   link l;
   string command ;
   string file_k;
    while(k <= N) {
        file_k = string(k) + ".ssi";  
        l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
             command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
            kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,4200);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   link l;
   string command ;
   string file_k;
    while(k <= N) {
        file_k = string(k) + ".ssi";  
        l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
             command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
                 kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,7200);
c;
rtimer-t;
quit;
;
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data;
proc Add_GPI(token input, int N)
{
    def inputRing = basering;  // Save the input ring
    string path1 = "/home/santosh/gspc-res/example_dir/temp/";
   
    // string filename = "Reduce.ssi";
  
    // link l0 = "ssi:w " + path1 + filename;
  
    def f = input.data[1];  
    int r = size(f);        
    smatrix C;  // Initialize C
    module M;
   int first_time = 0;  // Initialize first_time as 0 (false)
   int k=1;
   link l;
   string command ;
   string file_k;
    while(k <= N) {
        file_k = string(k) + ".ssi";  
        l = "ssi:r " + path1 + file_k;  
        if (status(l, "exists") == "yes") 
        {
          def t = read(l);  //Read file
          close(l);  // Close  l after reading
  
          def nr = t.r_data;
          setring nr;
          module M;
          smatrix sM = t.data[2];
          kill t;
          // write(l0,sM,"sM");
          M=sM;
          setring inputRing;
           M = fetch(nr, M);
           sM=M;
           kill M;
          //  C = fetch(inputRing, C);
          // Logic to initialize or update C
         
             if (first_time == 0) 
             {  
            // sM=fetch(inputRing,sM);
              // write(l0,first_time,"first_time"); 
                     C = sM;  // Initialize C with sM       
                     first_time = 1;  // Set first_time to 1 (true) after initialization
             } else {
                  // sM=fetch(inputRing,sM);
                     C = C + sM;           
                 } 
              kill sM;
             command = "rm " + path1 + file_k;  // Construct the remove command
            system("sh", command);  // Execute the shell command to remove the file
           } 
                 kill nr;
                  k=k+1;
                 
          
            // Print C only when k == N (final iteration)
          
    }
 
    token output;
    output.fieldnames = list("generators", "FirstSyz_matrix");   
    output.data[1] = C;  
    output.data[2] = r;   
    output.data[3] = ncols(C);  
    return(output);
}
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
def c= Add_GPI(m,13800);
c;
rtimer-t;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
quit;
;
link l="ssi:r temp/1.ssi";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
link l="ssi:r temp/schipp_33930_1743541393680769839";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
m.data[3];
m.data[4];
m.data[5];
m.data[6];
m.data[7];
quit;
;
link l="ssi:r temp/schipp_35717_1743542785074207129";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data[1];
link l="ssi:r temp/input";
def m=read(l);
def nr=m.r_data;
setring nr;
m.data[1];
m.data[2];
quit;
quit;
quit;
quit;
quit;
ring R=0, (x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10),dp;
ideal J0;
J0[1]=5478184*x7+17974881*x8+10172252*x9+3606363*x10;
J0[2]=181233*x6+896498*x7+2615211*x8+1387366*x9+625050*x10;
J0[3]=4925*x5-237*x6-17222*x7-54504*x8-28574*x9-11575*x10;
J0[4]=132*x4-31*x5+213*x6+826*x7+2346*x8+1222*x9+629*x10;
J0[5]=336*x3+164*x4+821*x5+537*x6-462*x7-1774*x8-866*x9-263*x10;
J0[6]=254*x2+177*x3-27*x4+5*x5+123*x6+217*x7+306*x8+172*x9+137*x10;
J0[7]=x1-6*x2-4*x3-3*x6-4*x7-6*x8-3*x9-3*x10;
J0[8]=x0-39*x2-28*x3+4*x4-x5-19*x6-33*x7-48*x8-26*x9-21*x10;
print("ideal J=");
module J=J0;
J;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 def f0=fres(J,0);
 rtimer-t;
print("timer");
ring R=0, (x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10),dp;
ideal J0;
J0[1]=5478184*x7+17974881*x8+10172252*x9+3606363*x10;
J0[2]=181233*x6+896498*x7+2615211*x8+1387366*x9+625050*x10;
J0[3]=4925*x5-237*x6-17222*x7-54504*x8-28574*x9-11575*x10;
J0[4]=132*x4-31*x5+213*x6+826*x7+2346*x8+1222*x9+629*x10;
J0[5]=336*x3+164*x4+821*x5+537*x6-462*x7-1774*x8-866*x9-263*x10;
J0[6]=254*x2+177*x3-27*x4+5*x5+123*x6+217*x7+306*x8+172*x9+137*x10;
J0[7]=x1-6*x2-4*x3-3*x6-4*x7-6*x8-3*x9-3*x10;
J0[8]=x0-39*x2-28*x3+4*x4-x5-19*x6-33*x7-48*x8-26*x9-21*x10;
J0;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t0=rtimer;
 def f0=fres(J,0);
 rtimer-t0;
print("timer");
rtimer=0;
 system("--ticks-per-sec",1000000); // set timer resolution to ms
 int t1=rtimer;
 def f0=fres(J,0);
 rtimer-t1;
print("timer");
rtimer=0;
 system("--ticks-per-sec", 1000000000);
 int t2=rtimer;
 def f0=fres(J0,0);
 rtimer-t2;
print("timer");
quit;
// ring R = 0, (x0, x1, x2, x3, x4, x5), (dp,c);
// poly f1 = x0 + x1 + x2 + x3;
// poly f2 = x0*x1 + x2*x3 + x4*x5;
// poly f3 = x0*x2 + x1*x3;
// poly f4 = x0*x3 + x1*x4 + x2*x5;
// poly f5 = x0*x4 + x1*x5;
// ideal J0 = f1, f2, f3, f4, f5;
// ideal J1=std(J0);
quit;
ring R = 0, (x0, x1, x2, x3, x4, x5), (dp,c);
poly f1 = x0 + x1 + x2 + x3;
poly f2 = x0*x1 + x2*x3 + x4*x5;
poly f3 = x0*x2 + x1*x3;
poly f4 = x0*x3 + x1*x4 + x2*x5;
poly f5 = x0*x4 + x1*x5;
ideal J0 = f1, f2, f3, f4, f5;
ideal J1=std(J0);
J1;
rtimer=0;
system("--ticks-per-sec", 1000000000); // set timer resolution to ns
 int t=rtimer;
 def f0=fres(J1,0);
 rtimer-t;
print("timer");
quit;
 ring R = 0, (x0, x1, x2, x3, x4), (dp,c); // Example for n+1 = 5 variables
// Step 2: Generate a regular sequence
poly f1 = x0^2 + x1^2 + x2^2 + x3^2 + x4^2;
poly f2 = x0*x1 + x2*x3 + x4^2;
poly f3 = x0*x2 + x1*x3 + x4*x0;
poly f4 = x0*x3 + x1*x4 + x2*x0;
poly f5 = x0*x4 + x1*x2 + x3*x1;
ideal J0= f1,f2,f3,f4,f5;
ideal J1= std(J0);
rtimer=0;
system("--ticks-per-sec", 1000000000); // set timer resolution to ns
 int t=rtimer;
 def f0=fres(J1,0);
 rtimer-t;
print("timer");
quit;
ring R = 0, (x0, x1, x2, x3, x4), (dp,c);
// Define the generators of the ideal for the canonical genus 5 curve
poly Q1 = x0*x1 - x2^2;
poly Q2 = x0*x2 - x1*x3;
poly Q3 = x0*x3 - x1*x4;
poly Q4 = x0*x4 - x2*x3;
poly Q5 = x1*x2 - x3^2;
poly Q6 = x1*x3 - x2*x4;
poly Q7 = x1*x4 - x3*x4;
poly Q8 = x2*x3 - x4^2;
poly Q9 = x2*x4 - x3*x0;
poly Q10 = x3*x4 - x0*x1;
// Define the ideal
ideal J0= Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, Q10;
print("GB");
ideal J1=std(J0);
rtimer=0;
system("--ticks-per-sec", 1000000000); // set timer resolution to ns
 int t=rtimer;
 def f0=fres(J1,0);
 rtimer-t;
print("timer");
quit;
ring R= 0, (w,x,y,z), (dp,c);
ideal J0= w2-x*z, w*x- y*z, x2-w*y, x*y- z2, y2- w*z;
module J=J0;
module m;
vector s1=[-x,w,-z,0,0];
vector s2=[y,-x,w,0,0];
vector s3=[0,-y,0,w,-z];
vector s4=[-z,0,-y,x,-w];
vector s5=[-y^2+w*z, z^2,0,-yz,w^2];
vector s6=[0,z,0,-y,x];
module m=s1,s2,s3,s4,s5,s6;
  // Example2:
ring R= 0, (x(1),x(2),x(3),x(4),x(5),x(6),x(7),x(8)), (lp,c);
matrix mS[2][4]= x(4)+ x(6), x(6)+ x(3), x(8)+ x(3), x(1)-x(3), x(2)-x(4), x(5)-x(7), x(8)-x(7), x(2)+ x(3);
ideal I_minor= minor(mS,2);
ideal J1 = std(I_minor);
J1;
rtimer=0;
system("--ticks-per-sec", 1000000000); // set timer resolution to ns
 int t=rtimer;
 def f0=fres(J1,0);
 rtimer-t;
print("timer");
quit;
ring R= 0, (w,x,y,z), (dp,c);
ideal J1= w2-x*z, w*x- y*z, x2-w*y, x*y- z2, y2- w*z;
rtimer=0;
system("--ticks-per-sec", 1000000000); // set timer resolution to ns
 int t=rtimer;
 def f0=fres(J1,0);
 rtimer-t;
print("timer");
quit;
quit;
